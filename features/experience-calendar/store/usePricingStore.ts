import { defineStore } from "pinia";
import { watchDebounced } from "@vueuse/core";
import { getByPath } from "dot-path-value";
import { paxPricingFormSchema, pricingFormSchema } from "@/features/experience-calendar/schemas/pricing.schema";
import { useOfferServiceApi } from "@/composables/useOfferServiceApi";
import { Pricing } from "@/types/generated/OfferServiceApiOld";
import { HolderCard, PricingCard } from "@/types/Pricing";
import {
  createHolderCard,
  createPricingCard,
  getDefaultPricingFields,
  getNewOrEditedPricings,
  getRemovedPricings,
  mapPaxPricingsToApiPricings,
  mapPricingsToPricingCards,
  mapApiPaxesToPaxTypes,
  pricingMapToService,
} from "../lib/experience-option-pricing";
import { useFeatureFlag } from "@/features/experience-shared/composables/useFeatureFlag";
import { cloneDeep } from "lodash";
import { PaxType } from "../components/PricingFormPaxPricingList/PricingFormPaxPricingTypes";

export type ExperiencePricingState = {
  experienceId: string | undefined;
  optionId: string | undefined;
  pricingCards: PricingCard[];
  paxTypes: PaxType[];
};

export const usePricingStore = defineStore("pricing-store", () => {
  // State
  const state = reactive<ExperiencePricingState>({
    experienceId: undefined,
    optionId: undefined,
    pricingCards: [],
    paxTypes: [],
  });

  let lastSavedPricingCards: PricingCard[] = [];

  // Getters
  const pricings = computed((): Pricing[] => {
    const currentPricingCards = state.pricingCards || [];
    const holders = [];

    for (const pricingCard of currentPricingCards) {
      for (const holder of pricingCard.holders) {
        if (holder.fields.id) {
          holders.push(holder.fields);
        }
      }
    }

    return holders;
  });

  // pricing form
  const isPricingFormValid = ref(false);
  const pricingFormErrors = ref<Record<string, unknown>>({});

  /**
   * Returns the error generated by zod for the given path
   * @param path path to the error using dot notation (prefix with the pricing index)
   * @example getPricingError("0.name"); getPricingError("0.age_range.from");
   */
  const getPricingError = (path: string) => {
    const errorPath = path + "._errors.0";
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const err = getByPath(pricingFormErrors.value, errorPath);
    return !!err;
  };

  const updateIndexes = () => {
    let index = 0;
    state.pricingCards.forEach((card) => {
      card.holders.forEach((holderCard) => {
        holderCard.pricingIndex = index;
        index++;
      });
    });
  };

  const validate = (cards: PricingCard[]) => {
    useFeatureFlag("pax_enabled") ? validatePaxPricings(cards) : validatePricingForm(cards);
  };

  // a form library or useField hook would improve this logic
  const validatePricingForm = (cards: PricingCard[]) => {
    const holders: Pricing[] = [];
    for (const pricingCard of cards) {
      for (const holder of pricingCard.holders) {
        const payload = pricingMapToService(pricingCard.pricingName, holder.fields);
        holders.push(payload);
      }
    }

    const result = pricingFormSchema.safeParse(holders);
    if (!result.success) {
      pricingFormErrors.value = result.error.format();
    } else {
      pricingFormErrors.value = {};
    }

    isPricingFormValid.value = result.success;
  };

  const validatePaxPricings = (cards: PricingCard[]) => {
    const pricings = cards.flatMap((pricingCard) =>
      mapPaxPricingsToApiPricings(
        state.optionId!,
        pricingCard.pricingName,
        state.paxTypes.length > 0 ? state.paxTypes : pricingCard.paxTypes,
        pricingCard.paxPricingList
      )
    );

    const result = paxPricingFormSchema.safeParse(pricings);
    if (!result.success) {
      pricingFormErrors.value = result.error.format();
    } else {
      pricingFormErrors.value = {};
    }

    const anyCardWithoutPricings = cards.some((card) => card.paxPricingList.length === 0);
    const nonFreeOfChargePaxTypes = state.paxTypes
      .filter((paxType) => !paxType.freeOfCharge)
      .map((paxType) => paxType.code);
    const anyNonFreeOfChargePaxTypeWithoutPrice = cards.some((card) =>
      card.paxPricingList
        .filter((paxPrice) => nonFreeOfChargePaxTypes.includes(paxPrice.paxTypeCode))
        .some((paxPrice) => paxPrice.pricing.retailPrice === 0)
    );

    isPricingFormValid.value = result.success && !anyCardWithoutPricings && !anyNonFreeOfChargePaxTypeWithoutPrice;
  };

  watchDebounced(
    () => state.pricingCards,
    () => {
      validate(state.pricingCards);

      if (state.pricingCards.length) {
        state.pricingCards[0].isOpen = true;
      }
    },
    { debounce: 500, maxWait: 2000, deep: true }
  );

  const handleAddPricing = (optionId: string, pricingType: Pricing["pricing_type"]) => {
    if (state.pricingCards) {
      const newPricingCard = createPricingCard("", { isOpen: true });
      const newHolder = createHolderCard(getDefaultPricingFields(optionId, pricingType));
      newPricingCard.holders.push(newHolder);
      state.pricingCards.push(newPricingCard);
    }
    updateIndexes();
  };

  const handleAddHolder = (pricing: PricingCard, optionId: string, pricingType: Pricing["pricing_type"]) => {
    const newHolder = createHolderCard(getDefaultPricingFields(optionId, pricingType));
    newHolder.fields.name = pricing.pricingName;
    pricing.holders.push(newHolder);
    updateIndexes();
  };

  /**
   * Deletes a pricing card from the store pricing list and deletes the holders from the offer service
   * @param optionId
   */
  async function deletePricingCard(optionId: string, pricingCardId: string, holders: HolderCard[]) {
    const offerService = useOfferServiceApi();
    const pricing = state.pricingCards.find((p) => p.cardId === pricingCardId);

    if (!pricing) {
      throw new Error("No pricings for the option: " + optionId);
    }

    for (const holder of holders) {
      // don't make an api call for new holders
      if (holder.fields.id) {
        await offerService.deletePricing(holder.fields.id);
      }
      // remove holders
      pricing.holders = pricing.holders.filter((existingHolder) => {
        return holder.cardId !== existingHolder.cardId;
      });
      // remove the pricing if no holders left
      if (pricing.holders.length === 0) {
        state.pricingCards = state.pricingCards.filter((card) => card.cardId !== pricing.cardId);
      }
    }
    await nextTick(); // wait for elements to be removed from dom
    updateIndexes();
  }

  async function save(optionId: string) {
    if (useFeatureFlag("pax_enabled")) {
      await savePaxPricings();
    } else {
      await savePricingCards(optionId);
    }
  }

  /**
   * Saves all the pricing cards stored. It will create new pricings or update existing ones
   * @param optionId
   */
  async function savePricingCards(optionId: string) {
    const offerService = useOfferServiceApi();

    if (!pricings.value) {
      throw new Error("No pricings for the option: " + optionId);
    }

    for (const pricingCard of state.pricingCards) {
      for (const holder of pricingCard.holders) {
        if (holder.isChanged) {
          const payload = {
            ...holder.fields,
          };

          // Note: each holder is a Pricing.
          // create or update
          const { data } = payload.id
            ? await offerService.updatePricing(payload)
            : await offerService.createPricing(payload);

          holder.fields.id = data.id; // update the id
          holder.isChanged = false; // reset the changed state
        }
      }
    }
  }

  /**
   * Saves all the newly defined or edited pricings, delete the removed ones.
   */
  async function savePaxPricings() {
    const offerService = useOfferServiceApi();

    if (!state.optionId) {
      throw new Error("No optionId");
    }

    const workingCopyPricings = state.pricingCards.flatMap((pricingCard) =>
      mapPaxPricingsToApiPricings(state.optionId!, pricingCard.pricingName, state.paxTypes, pricingCard.paxPricingList)
    );
    const lastSavedPricings = lastSavedPricingCards.flatMap((pricingCard) =>
      mapPaxPricingsToApiPricings(state.optionId!, pricingCard.pricingName, state.paxTypes, pricingCard.paxPricingList)
    );

    const savePromises = getNewOrEditedPricings(workingCopyPricings, lastSavedPricings).map((pricingToSave) =>
      pricingToSave.id ? offerService.updatePricing(pricingToSave) : offerService.createPricing(pricingToSave)
    );
    const deletePromises = getRemovedPricings(workingCopyPricings, lastSavedPricings).map((pricingToDelete) =>
      offerService.deletePricing(pricingToDelete.id!)
    );

    await Promise.all([Promise.all(savePromises), Promise.all(deletePromises)]);

    await refreshData();
  }

  async function loadData(experienceId: string, optionId: string) {
    const offerService = useOfferServiceApi();

    state.experienceId = experienceId;
    state.optionId = optionId;

    const [{ data: apiPricings }, { data: apiExperiencePaxes }] = await Promise.all([
      offerService.getPricings(experienceId, optionId),
      offerService.getExperiencePaxes(experienceId),
    ]);

    const pricingCards = mapPricingsToPricingCards(apiPricings);
    lastSavedPricingCards = cloneDeep(pricingCards);
    state.pricingCards = pricingCards;
    state.paxTypes = mapApiPaxesToPaxTypes(apiExperiencePaxes.pax_list);
  }

  async function refreshData() {
    if (!state.experienceId || !state.optionId) {
      throw new Error("can't refresh data without experienceId or optionId");
    }

    await loadData(state.experienceId, state.optionId);
  }

  return {
    // State
    state,
    isPricingFormValid,
    pricingFormErrors,
    // Getters
    pricings,
    // Actions
    loadData,
    getPricingError,
    handleAddPricing,
    handleAddHolder,
    deletePricingCard,
    save,
  };
});
